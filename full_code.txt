# -*- coding: utf-8 -*-
import tkinter as tk
from tkinter import ttk
import ctypes
from ctypes import wintypes
import time
import json
import os
import win32com.client
import win32gui
import win32con
import re
import math # Added for animation
import glob
from tkinter import messagebox
from PIL import Image, ImageTk
from datetime import datetime, timedelta
import traceback # Added as per instruction

# --- Store Compatibility Imports ---
import sys
import shutil
# Using ctypes for Mutex to avoid extra pywin32 module dependencies if not strictly needed,
# though win32event is also fine since win32gui is used.
# sticking to ctypes kernel32 for zero-dependency bloat for this specific feature.
kernel32 = ctypes.windll.kernel32


# --- Application Constants ---
VERSION = "v1.0.4"


# --- Windows API Constants & Structures ---
ABM_NEW = 0x00000000
ABM_REMOVE = 0x00000001
ABM_QUERYPOS = 0x00000002
ABM_SETPOS = 0x00000003
ABM_GETSTATE = 0x00000004
ABM_GETTASKBARPOS = 0x00000005
ABM_ACTIVATE = 0x00000006
ABM_GETAUTOHIDEBAR = 0x00000007
ABM_SETAUTOHIDEBAR = 0x00000008
ABM_WINDOWPOSCHANGED = 0x00000009
ABM_SETSTATE = 0x0000000A

ABE_LEFT = 0
ABE_TOP = 1
ABE_RIGHT = 2
ABE_BOTTOM = 3

class APPBARDATA(ctypes.Structure):
    _fields_ = [
        ('cbSize', wintypes.DWORD),
        ('hWnd', wintypes.HWND),
        ('uCallbackMessage', wintypes.UINT),
        ('uEdge', wintypes.UINT),
        ('rc', wintypes.RECT),
        ('lParam', wintypes.LPARAM),
    ]

class MONITORINFO(ctypes.Structure):
    _fields_ = [
        ('cbSize', wintypes.DWORD),
        ('rcMonitor', wintypes.RECT),
        ('rcWork', wintypes.RECT),
        ('dwFlags', wintypes.DWORD),
    ]

shell32 = ctypes.windll.shell32
user32 = ctypes.windll.user32

class AppBarManager:
    """
    Manages the Windows AppBar registration and positioning.
    """
    def __init__(self, hwnd, edge=ABE_LEFT):
        self.hwnd = hwnd
        self.edge = edge
        self.registered = False
        self.uCallbackMessage = 0x0400 + 1  # WM_USER + 1
        
        # Keep appbar data persistent
        self.abd = APPBARDATA()
        self.abd.cbSize = ctypes.sizeof(APPBARDATA)
        self.abd.hWnd = self.hwnd
        self.abd.uCallbackMessage = self.uCallbackMessage
        self.abd.uEdge = self.edge

    def register(self):
        """Registers the window as an AppBar."""
        if not self.registered:
            shell32.SHAppBarMessage(ABM_NEW, ctypes.byref(self.abd))
            self.registered = True

    def unregister(self):
        """Unregisters the AppBar."""
        if self.registered:
            shell32.SHAppBarMessage(ABM_REMOVE, ctypes.byref(self.abd))
            self.registered = False

    def set_pos(self, width, monitor_left, monitor_top, monitor_width, monitor_height):
        """
        Reserving space for the AppBar on the current monitor's edge.
        """
        if not self.registered:
            return

        # 1. Query Position
        if self.edge == ABE_LEFT:
            self.abd.rc.left = monitor_left
            self.abd.rc.top = monitor_top
            self.abd.rc.right = monitor_left + width
            self.abd.rc.bottom = monitor_top + monitor_height
        elif self.edge == ABE_RIGHT:
            self.abd.rc.left = monitor_left + monitor_width - width
            self.abd.rc.top = monitor_top
            self.abd.rc.right = monitor_left + monitor_width
            self.abd.rc.bottom = monitor_top + monitor_height
        
        # Query the system for an approved position
        shell32.SHAppBarMessage(ABM_QUERYPOS, ctypes.byref(self.abd))
        
        # 2. Adjust if necessary
        if self.edge == ABE_LEFT:
            self.abd.rc.right = self.abd.rc.left + width
        elif self.edge == ABE_RIGHT:
            self.abd.rc.left = self.abd.rc.right - width
        
        # 3. Set Position
        shell32.SHAppBarMessage(ABM_SETPOS, ctypes.byref(self.abd))
        
        # Return the actual rectangle committed
        return self.abd.rc.left, self.abd.rc.top, self.abd.rc.right - self.abd.rc.left, self.abd.rc.bottom - self.abd.rc.top

class ScrollableFrame(tk.Frame):
    """
    A scrollable frame that can contain multiple email cards.
    """
    def __init__(self, container, *args, **kwargs):
        super().__init__(container, *args, **kwargs)
        self.canvas = tk.Canvas(self, bg=kwargs.get("bg", "#222222"), highlightthickness=0)
        self.scrollable_frame = tk.Frame(self.canvas, bg=kwargs.get("bg", "#222222"))

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )

        self.window_id = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        # Custom Scroll Buttons
        # We place them relative to 'self' so they overlay the canvas
        self.btn_up = tk.Button(self, text="‚ñ≤", command=lambda: self.scroll(-1), 
                                bg="#444444", fg="white", bd=0, font=("Arial", 6), width=10, activebackground="#555555", activeforeground="white")
        self.btn_down = tk.Button(self, text="‚ñº", command=lambda: self.scroll(1), 
                                  bg="#444444", fg="white", bd=0, font=("Arial", 6), width=10, activebackground="#555555", activeforeground="white")

        self.canvas.configure(yscrollcommand=self._on_scroll_update)
        self.canvas.pack(side="left", fill="both", expand=True)
        # self.scrollbar removed
        
        # Mousewheel scrolling
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # Ensure scrollable frame matches canvas width
        self.canvas.bind("<Configure>", self._on_canvas_configure)

    def _on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
    def scroll(self, direction):
        self.canvas.yview_scroll(direction, "units")

    def _on_scroll_update(self, first, last):
        # first and last are strings "0.0" to "1.0"
        f = float(first)
        l = float(last)
        
        if f <= 0.001:
            self.btn_up.place_forget()
        else:
            self.btn_up.place(relx=0.5, rely=0, anchor="n", height=15, relwidth=1.0)
            self.btn_up.lift() # Ensure on top
            
        if l >= 0.999:
            self.btn_down.place_forget()
        else:
            self.btn_down.place(relx=0.5, rely=1.0, anchor="s", height=15, relwidth=1.0)
            self.btn_down.lift() # Ensure on top
        
    def _on_canvas_configure(self, event):
        # Resize the inner frame to match the canvas width
        self.canvas.itemconfig(self.window_id, width=event.width)


class RoundedFrame(tk.Canvas):
    def __init__(self, parent, width, height, corner_radius, padding, color, bg, **kwargs):
        tk.Canvas.__init__(self, parent, width=width, height=height, bg=bg, bd=0, highlightthickness=0, **kwargs)
        self.radius = corner_radius
        self.padding = padding
        self.color = color
        
        self.id = self.create_rounded_rect(0, 0, width, height, self.radius, fill=self.color, outline="")
        
        # Inner frame for widgets
        self.inner = tk.Frame(self, bg=self.color)
        self.window_id = self.create_window((padding, padding), window=self.inner, anchor="nw")
        
        self.bind("<Configure>", self._on_resize)
        
    def _on_resize(self, event):
        self.coords(self.id, self._rounded_rect_coords(0, 0, event.width, event.height, self.radius))
        self.itemconfig(self.window_id, width=event.width - 2*self.padding, height=event.height - 2*self.padding)
        
    def create_rounded_rect(self, x1, y1, x2, y2, r, **kwargs):
        return self.create_polygon(self._rounded_rect_coords(x1, y1, x2, y2, r), **kwargs)

    def _rounded_rect_coords(self, x1, y1, x2, y2, r):
        points = [x1+r, y1,
                  x1+r, y1,
                  x2-r, y1,
                  x2-r, y1,
                  x2, y1,
                  x2, y1+r,
                  x2, y1+r,
                  x2, y2-r,
                  x2, y2-r,
                  x2, y2,
                  x2-r, y2,
                  x2-r, y2,
                  x1+r, y2,
                  x1+r, y2,
                  x1, y2,
                  x1, y2-r,
                  x1, y2-r,
                  x1, y1+r,
                  x1, y1+r,
                  x1, y1]
        return points

class ToolTip:
    """
    Creates a popup tooltip for a given widget.
    """
    def __init__(self, widget, text, side="bottom"):
        self.widget = widget
        self.text = text
        self.side = side # "bottom", "left", "right", "top"
        self.tip_window = None
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)

    def enter(self, event=None):
        self.show_tip()

    def leave(self, event=None):
        self.hide_tip()

    def show_tip(self):
        """Displays the tooltip."""
        if self.tip_window or not self.text:
            return
        
        # Create window first to get size
        self.tip_window = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_attributes("-topmost", True)
        
        label = tk.Label(
            tw, 
            text=self.text, 
            justify="left",
            bg="#2d2d2d", 
            fg="#ffffff",
            relief="solid", 
            borderwidth=1,
            font=("Segoe UI", 8),
            padx=4, pady=2
        )
        label.pack(ipadx=1)
        
        tw.update_idletasks() # Calculate size
        
        tw_width = tw.winfo_reqwidth()
        tw_height = tw.winfo_reqheight()
        
        widget_x = self.widget.winfo_rootx()
        widget_y = self.widget.winfo_rooty()
        widget_w = self.widget.winfo_width()
        widget_h = self.widget.winfo_height()
        
        if self.side == "left":
            x = widget_x - tw_width - 5
            y = widget_y + (widget_h // 2) - (tw_height // 2)
        elif self.side == "right":
            x = widget_x + widget_w + 5
            y = widget_y + (widget_h // 2) - (tw_height // 2)
        elif self.side == "top":
            x = widget_x + (widget_w // 2) - (tw_width // 2)
            y = widget_y - tw_height - 5
        else: # bottom
            x = widget_x + 20
            y = widget_y + widget_h + 5
            
        tw.wm_geometry(f"+{x}+{y}")

    def hide_tip(self):
        """Hides the tooltip."""
        if self.tip_window:
            self.tip_window.destroy()
            self.tip_window = None

class OutlookClient:
    def __init__(self):
        self.outlook = None
        self.namespace = None
        self.last_received_time = None
        self.connect()
        # Initialize last_received_time
        if self.namespace:
            self.check_latest_time()

    def connect(self):
        """Attempts to connect to the Outlook COM object."""
        try:
            self.outlook = win32com.client.Dispatch("Outlook.Application")
            self.namespace = self.outlook.GetNamespace("MAPI")
            # print("Connected to Outlook")
            return True
        except Exception as e:
            print(f"Error connecting to Outlook: {e}")
            self.outlook = None
            self.namespace = None
            return False

    def check_latest_time(self):
        """Initializes or updates the last received time without returning bool."""
        if not self.namespace: return
        try:
            inbox = self.namespace.GetDefaultFolder(6)
            items = inbox.Items
            items.Sort("[ReceivedTime]", True)
            item = items.GetFirst()
            if item:
                self.last_received_time = item.ReceivedTime
        except Exception:
             # If we fail here, we might be disconnected, but this is just init
             pass

    def check_new_mail(self):
        """Checks if there is email newer than the last check. Recovers connection if needed."""
        # Retry loop (Try once, if fail, reconnect and try again)
        for attempt in range(2):
            if not self.namespace:
                if not self.connect():
                    return False # Still cannot connect

            try:
                inbox = self.namespace.GetDefaultFolder(6)
                items = inbox.Items
                items.Sort("[ReceivedTime]", True)
                item = items.GetFirst()
                
                if item:
                    current_time = item.ReceivedTime
                    # If we have a stored time and the new one is newer
                    if self.last_received_time and current_time > self.last_received_time:
                        self.last_received_time = current_time
                        return True
                    
                    # Update tracker regardless to avoid stale alerts
                    self.last_received_time = current_time
                return False # No new mail
                
            except Exception as e:
                print(f"Polling error (Attempt {attempt+1}): {e}")
                self.namespace = None # Force reconnect next loop
        
        return False

    def get_inbox_items(self, count=20, unread_only=False, only_flagged=False, include_read_flagged=True, flag_date_filter="Anytime"):
        # Retry loop
        for attempt in range(2):
            if not self.namespace:
                if not self.connect():
                    return []

            try:
                inbox = self.namespace.GetDefaultFolder(6) # 6 = olFolderInbox
                items = inbox.Items
                
                # Build restriction string
                restricts = []
                
                if only_flagged:
                    # [FlagStatus] <> 0 correctly identifies flagged items
                    restricts.append("[FlagStatus] <> 0")
                    # Sub-filter: Only apply unread restriction if NOT including read flagged
                    if not include_read_flagged:
                        restricts.append("[UnRead] = True")
                    
                    # Date Filter Logic
                    if flag_date_filter and flag_date_filter != "Anytime":
                        now = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
                        if flag_date_filter == "Today":
                            start = now
                            end = now + timedelta(days=1)
                            restricts.append(f"[TaskDueDate] >= '{start.strftime('%m/%d/%Y %I:%M %p')}' AND [TaskDueDate] < '{end.strftime('%m/%d/%Y %I:%M %p')}'")
                        elif flag_date_filter == "Tomorrow":
                            start = now + timedelta(days=1)
                            end = now + timedelta(days=2)
                            restricts.append(f"[TaskDueDate] >= '{start.strftime('%m/%d/%Y %I:%M %p')}' AND [TaskDueDate] < '{end.strftime('%m/%d/%Y %I:%M %p')}'")
                        elif flag_date_filter == "This Week":
                            # Next 7 days
                            end = now + timedelta(days=7)
                            restricts.append(f"[TaskDueDate] >= '{now.strftime('%m/%d/%Y %I:%M %p')}' AND [TaskDueDate] < '{end.strftime('%m/%d/%Y %I:%M %p')}'")
                        elif flag_date_filter == "Next Week":
                            # Days 7 to 14
                            start = now + timedelta(days=7)
                            end = now + timedelta(days=14)
                            restricts.append(f"[TaskDueDate] >= '{start.strftime('%m/%d/%Y %I:%M %p')}' AND [TaskDueDate] < '{end.strftime('%m/%d/%Y %I:%M %p')}'")
                        elif flag_date_filter == "No Date":
                            # Outlook uses 4501-01-01 for "No Date" tasks
                            restricts.append("[TaskDueDate] > '01/01/4500'")
                else:
                    # Global filter: Only unread
                    if unread_only:
                        restricts.append("[UnRead] = True")
                
                if restricts:
                    restrict_str = " AND ".join(restricts)
                    items = items.Restrict(restrict_str)
                
                items.Sort("[ReceivedTime]", True) # Descending
                
                email_list = []
                for i, item in enumerate(items):
                    if i >= count:
                        break
                    try:
                        subject = getattr(item, "Subject", "[No Subject]")
                        sender = getattr(item, "SenderName", "Unknown")
                        raw_body = getattr(item, "Body", "")
                        
                        # Clean up body: remove newlines and extra spaces
                        clean_body = re.sub(r'\s+', ' ', raw_body).strip()
                        body = clean_body[:100] + "..." # Preview
                        
                        unread = getattr(item, "UnRead", False)
                        
                        email_list.append({
                            "sender": sender,
                            "subject": subject,
                            "preview": body,
                            "unread": unread,
                            "entry_id": getattr(item, "EntryID", ""),
                            "received": getattr(item, "ReceivedTime", None),
                            "flag_status": getattr(item, "FlagStatus", 0),
                            "due_date": getattr(item, "TaskDueDate", None)
                        })
                    except Exception as inner_e:
                        print(f"Error reading item: {inner_e}")
                        
                return email_list
            except Exception as e:
                print(f"Fetch error (Attempt {attempt+1}): {e}")
                self.namespace = None # Force reconnect
        
        
        return []

    def get_item_by_entryid(self, entry_id):
        """Retrieves a specific Outlook item by its EntryID."""
        if not self.namespace:
            self.connect()
        try:
            return self.namespace.GetItemFromID(entry_id)
        except Exception as e:
            print(f"Error getting item {entry_id}: {e}")
            return None

    def find_folder_by_name(self, folder_name):
        """
        Recursively searches for a folder by name. 
        Starts at default Inbox parent (likely the account root).
        This is a simple implementation; heavy trees might need optimization.
        """
        if not self.namespace: return None
        
        try:
            # Start at root of the default store
            root = self.namespace.GetDefaultFolder(6).Parent # Inbox -> Parent (Account Root)
            
            # Helper for recursion
            def recursive_find(folder):
                if folder.Name.lower() == folder_name.lower():
                    return folder
                for sub in folder.Folders:
                    found = recursive_find(sub)
                    if found: return found
                return None

            return recursive_find(root)
        except Exception as e:
            print(f"Error finding folder {folder_name}: {e}")
            return None

    def get_folder_list(self):
        """Returns a list of folder paths (e.g. 'Inbox', 'Inbox/ProjectA')"""
        if not self.namespace: return []
        
        folders = []
        try:
            root = self.namespace.GetDefaultFolder(6).Parent
            
            def recurse(folder, parent_path=""):
                try:
                    name = folder.Name
                    path = f"{parent_path}/{name}" if parent_path else name
                    
                    # Add to list
                    folders.append(path)
                    
                    # Limit recursion depth to avoid slowdowns on massive mailboxes
                    # Only go 2 levels deep for now? Or just try all.
                    # Let's do 1 level deep for safety in this version.
                    if parent_path.count("/") < 2:
                        for sub in folder.Folders:
                            recurse(sub, path)
                except Exception:
                    pass

            # Start recursion
            for f in root.Folders:
                recurse(f)
                
        except Exception as e:
            print(f"Error fetching folder list: {e}")
            
        return sorted(folders)

class FolderPickerWindow(tk.Toplevel):
    def __init__(self, parent, folders, callback):
        super().__init__(parent)
        self.callback = callback
        self.folders = folders
        
        # Win11 Colors
        self.colors = {
            "bg": "#202020",
            "fg": "#FFFFFF",
            "accent": "#60CDFF", 
            "select_bg": "#444444"
        }
        
        self.overrideredirect(True)
        self.wm_attributes("-topmost", True)
        self.config(bg=self.colors["bg"])
        self.configure(highlightbackground=self.colors["accent"], highlightthickness=1)
        
        # Geometry
        w, h = 300, 400
        x = parent.winfo_x() + 50
        y = parent.winfo_y() + 50
        self.geometry(f"{w}x{h}+{x}+{y}")

        # Title Bar
        header = tk.Frame(self, bg=self.colors["bg"], height=30)
        header.pack(fill="x", side="top")
        header.bind("<Button-1>", self.start_move)
        header.bind("<B1-Motion>", self.on_move)

        lbl = tk.Label(header, text="Select Folder", bg=self.colors["bg"], fg=self.colors["fg"], font=("Segoe UI", 10, "bold"))
        lbl.pack(side="left", padx=10, pady=5)
        
        btn_close = tk.Label(header, text="‚úï", bg=self.colors["bg"], fg="#CCCCCC", cursor="hand2")
        btn_close.pack(side="right", padx=10)
        btn_close.bind("<Button-1>", lambda e: self.destroy())

        # TreeView
        tree_frame = tk.Frame(self, bg=self.colors["bg"])
        tree_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Treeview", 
            background="#2D2D30", 
            foreground="white", 
            fieldbackground="#2D2D30",
            borderwidth=0
        )
        style.map("Treeview", background=[("selected", self.colors["accent"])])

        self.tree = ttk.Treeview(tree_frame, show="tree", selectmode="browse")
        self.tree.pack(side="left", fill="both", expand=True)
        
        sb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        sb.pack(side="right", fill="y")
        self.tree.configure(yscrollcommand=sb.set)
        
        self.populate_tree()
        
        # Select Button
        btn_sel = tk.Button(self, text="Select", command=self.select_folder,
            bg=self.colors["accent"], fg="black", bd=0, font=("Segoe UI", 9, "bold"), pady=5)
        btn_sel.pack(fill="x", padx=10, pady=10)

    def populate_tree(self):
        # Build hierarchy from paths e.g. "Inbox/Sub"
        # Since we just have paths, we can just list them flat or try to build structure.
        # User asked for mirror of Outlook. Start simple: Tree nodes.
        
        # Logic to build tree from slash-paths
        nodes = {}
        
        for path in self.folders:
            parts = path.split("/")
            parent = ""
            current = ""
            
            for i, part in enumerate(parts):
                current = f"{parent}/{part}" if parent else part
                
                # Check if node exists
                if current not in nodes:
                    # Parent ID is clean parent path logic
                    pid = parent if parent else ""
                    
                    # Insert
                    nodes[current] = self.tree.insert(pid, "end", iid=current, text=part, open=False)
                
                parent = current

    def select_folder(self):
        sel = self.tree.selection()
        if sel:
            # The IID is the full path in our logic
            path = sel[0]
            self.callback(path)
            self.destroy()

    def start_move(self, event):
        self._x = event.x
        self._y = event.y

    def on_move(self, event):
        deltax = event.x - self._x
        deltay = event.y - self._y
        x = self.winfo_x() + deltax
        y = self.winfo_y() + deltay
        self.geometry(f"+{x}+{y}")


class SettingsWindow(tk.Toplevel):
    def __init__(self, parent, callback):
        try:
            super().__init__(parent)
            print("DEBUG: SettingsWindow __init__ started")
            self.main_window = parent 
            self.callback = callback
            
            # --- Pre-Initialize Variables (to avoid AttributeError in callbacks) ---
            # Safely get split_ratio (handle potential tkapp wrapper issue)
            current_split = getattr(self.main_window, "split_ratio", 0.66)
            
            # Determine initial combo value
            init_split_val = "50% / 50%"
            if current_split >= 0.9: init_split_val = "No Split"
            elif current_split >= 0.7: init_split_val = "75% Top"
            elif current_split >= 0.45: init_split_val = "50% / 50%"
            else: init_split_val = "25% Top"
            
            self.split_var = tk.StringVar(value=init_split_val)
            self.pane1_var = tk.StringVar(value=getattr(self.main_window, "pane1_type", "Emails"))
            self.pane2_var = tk.StringVar(value=getattr(self.main_window, "pane2_type", "Reminders"))
            
            self.show_read_var = tk.BooleanVar(value=getattr(self.main_window, "show_read", True))
            self.only_flagged_var = tk.BooleanVar(value=getattr(self.main_window, "only_flagged", False))
            
            self.action_rows = []
            
            # --- Windows 11 Dark Theme ---
            self.colors = {
                "bg_root": "#202020",       # Deep Dark
                "bg_card": "#2D2D30",       # Input BG
                "accent": "#60CDFF",        # Win11 Blue
                "fg_text": "#FFFFFF",
                "fg_dim": "#A0A0A0",
                "input_bg": "#333333"       
            }
            
            # Configure ttk Theme
            style = ttk.Style(self)
            try:
                style.theme_use("clam")
            except: pass
            
            style.configure("TCombobox", 
                fieldbackground=self.colors["input_bg"], 
                background=self.colors["bg_card"], 
                foreground="white",
                arrowcolor="white",
                bordercolor=self.colors["bg_root"],
                darkcolor=self.colors["bg_root"],
                lightcolor=self.colors["bg_root"]
            )
            style.map("TCombobox", fieldbackground=[("readonly", self.colors["input_bg"])])
            
            try:
                style.configure("TEntry", 
                    fieldbackground=self.colors["input_bg"], 
                    foreground="white",
                    bordercolor=self.colors["bg_root"],
                    lightcolor=self.colors["bg_root"],
                    darkcolor=self.colors["bg_root"]
                )
            except: pass
            
            style.configure("Horizontal.TScale", background=self.colors["bg_root"])

            # Window attributes
            self.overrideredirect(True)
            self.wm_attributes("-topmost", True)
            self.config(bg=self.colors["bg_root"])
            self.configure(highlightbackground="#444444", highlightthickness=1)
            
            # --- Geometry Calculation (Alongside Sidebar) ---
            # --- Geometry Calculation (Alongside Sidebar) ---
            w = 400
            h = self.main_window.winfo_height()
            
            # Get Sidebar Position
            sb_x = self.main_window.winfo_rootx()
            sb_y = self.main_window.winfo_rooty()
            sb_w = self.main_window.winfo_width()
            
            # Decide Left or Right side
            screen_w = self.winfo_screenwidth()
            
            if sb_x < (screen_w / 2):
                # Sidebar is likely on LEFT
                x = sb_x + sb_w + 5
            else:
                # Sidebar is likely on RIGHT
                x = sb_x - w - 5
                
            y = sb_y # Top-align with sidebar
            
            # bounds check
            if x < 0: x = 0
            
            self.geometry(f"{w}x{h}+{x}+{y}")
            print(f"DEBUG: Settings geometry {w}x{h}+{x}+{y}")
            
            # --- Header ---
            header = tk.Frame(self, bg=self.colors["bg_root"], height=40)
            header.pack(fill="x", side="top")
            
            lbl_title = tk.Label(header, text="Settings", fg=self.colors["fg_text"], bg=self.colors["bg_root"], font=("Segoe UI Variable Display", 14, "bold"))
            lbl_title.pack(side="left", padx=20, pady=10)
            
            # Red Cross Close
            btn_close = tk.Label(header, text="‚úï", fg="#FFFFFF", bg="#C42B1C", font=("Arial", 10), width=5, cursor="hand2")
            btn_close.pack(side="right", fill="y", padx=0)
            btn_close.bind("<Button-1>", lambda e: self.destroy())

            tk.Frame(self, bg=self.colors["accent"], height=1).pack(fill="x", side="top")

            # --- Content Container ---
            self.content = tk.Frame(self, bg=self.colors["bg_root"], padx=20, pady=10)
            self.content.pack(fill="both", expand=True)

            # Helper for Sections
            def add_section(title):
                f = tk.Frame(self.content, bg=self.colors["bg_root"])
                f.pack(fill="x", pady=(15, 5))
                tk.Label(f, text=title.upper(), fg=self.colors["accent"], bg=self.colors["bg_root"], font=("Segoe UI", 8, "bold")).pack(side="left")
                return f

            # --- 1. General (Fonts) ---
            add_section("General")

            # Font Config
            tk.Label(self.content, text="Font Style & Size", fg=self.colors["fg_dim"], bg=self.colors["bg_root"], font=("Segoe UI", 9)).pack(anchor="w", pady=(0, 2))
            
            font_frame = tk.Frame(self.content, bg=self.colors["bg_root"])
            font_frame.pack(fill="x", pady=(0, 10))
            
            fonts = [
                "Segoe UI", "Segoe UI Light", "Segoe UI Semibold",
                "Arial", "Calibri", "Cambria", "Consolas", 
                "Georgia", "Roboto", "Tahoma", "Trebuchet MS", "Verdana"
            ]
            
            self.font_fam_cb = ttk.Combobox(font_frame, values=fonts, width=15, state="readonly", font=("Segoe UI", 10))
            self.font_fam_cb.set(getattr(self.main_window, "font_family", "Segoe UI"))
            self.font_fam_cb.pack(side="left", fill="x", expand=True, padx=(0, 5))
            self.font_fam_cb.bind("<<ComboboxSelected>>", self.apply_changes)
            
            self.font_size_cb = ttk.Combobox(font_frame, values=[str(i) for i in range(8, 15)], width=4, state="readonly", font=("Segoe UI", 10))
            self.font_size_cb.set(str(getattr(self.main_window, "font_size", 9)))
            self.font_size_cb.pack(side="right")
            self.font_size_cb.bind("<<ComboboxSelected>>", self.apply_changes)

            # --- 2. Layout ---
            add_section("Layout")
            
            # Split Ratio Slider (Now Combobox)
            tk.Label(self.content, text="Split Position", fg=self.colors["fg_dim"], bg=self.colors["bg_root"], font=("Segoe UI", 9)).pack(anchor="w")
            
            split_opts = ["No Split", "75% Top", "50% / 50%", "25% Top"]
            self.split_combo = ttk.Combobox(self.content, values=split_opts, textvariable=self.split_var, state="readonly", font=("Segoe UI", 10))
            self.split_combo.pack(fill="x", pady=(0, 10))
            self.split_combo.bind("<<ComboboxSelected>>", self.on_split_change)
            
            # Pane Content Selectors
            pane_opts = ["Emails", "Reminders"]
            
            # Pane 1
            tk.Label(self.content, text="Primary View (Top / Full)", fg=self.colors["fg_dim"], bg=self.colors["bg_root"], font=("Segoe UI", 9)).pack(anchor="w")
            self.p1_combo = ttk.Combobox(self.content, values=pane_opts, textvariable=self.pane1_var, state="readonly", font=("Segoe UI", 10))
            self.p1_combo.pack(fill="x", pady=(0, 5))
            self.p1_combo.bind("<<ComboboxSelected>>", self.apply_changes)
            
            # Pane 2
            tk.Label(self.content, text="Secondary View (Bottom)", fg=self.colors["fg_dim"], bg=self.colors["bg_root"], font=("Segoe UI", 9)).pack(anchor="w")
            self.p2_combo = ttk.Combobox(self.content, values=pane_opts, textvariable=self.pane2_var, state="readonly", font=("Segoe UI", 10))
            self.p2_combo.pack(fill="x", pady=(0, 10))
            self.p2_combo.bind("<<ComboboxSelected>>", self.apply_changes)

            # --- 3. Content Filters ---
            add_section("Content Filters")
            
            # vars already init
            tk.Checkbutton(self.content, text="Show Read Emails", variable=self.show_read_var, 
                        bg=self.colors["bg_root"], fg="white", selectcolor=self.colors["bg_card"], activebackground=self.colors["bg_root"], font=("Segoe UI", 10),
                        command=self.apply_changes).pack(anchor="w")

            tk.Checkbutton(self.content, text="Only Flagged Emails", variable=self.only_flagged_var, 
                        bg=self.colors["bg_root"], fg="white", selectcolor=self.colors["bg_card"], activebackground=self.colors["bg_root"], font=("Segoe UI", 10),
                        command=self.apply_changes).pack(anchor="w")
            
            # --- 4. Quick Actions ---
            add_section("Quick Action Buttons")
            
            # Simplified Actions UI (List)
            self.action_options = ["None", "Mark Read", "Delete", "Read & Delete", "Flag", "Reply", "Move To..."]
            
            current_btn_config = getattr(self.main_window, "btn_config", [])
            
            for i in range(2): # Only showing 2 Primary Actions as per UI needs
                row_frame = tk.Frame(self.content, bg=self.colors["bg_root"])
                row_frame.pack(fill="x", pady=2)
                
                c_data = current_btn_config[i] if i < len(current_btn_config) else {}
                
                # Action Dropdown
                cb = ttk.Combobox(row_frame, values=self.action_options, state="readonly", font=("Segoe UI", 9))
                cb.set(c_data.get("action1", "None"))
                cb.pack(side="left", fill="x", expand=True, padx=(0,5))
                cb.bind("<<ComboboxSelected>>", self.apply_changes)
                
                # Folder (if Move To)
                e_folder = ttk.Entry(row_frame, width=10, font=("Segoe UI", 9))
                e_folder.insert(0, c_data.get("folder", ""))
                e_folder.pack(side="right")
                e_folder.bind("<Return>", lambda e: self.apply_changes())
                e_folder.bind("<FocusOut>", lambda e: self.apply_changes())
                
                self.action_rows.append({"cb": cb, "folder": e_folder})

            # --- Footer ---
            tk.Label(self.content, text="Changes apply immediately", fg=self.colors["fg_dim"], bg=self.colors["bg_root"], font=("Segoe UI", 8, "italic")).pack(side="bottom", pady=20)
        except Exception as e:
            messagebox.showerror("Settings Error", f"Failed to open settings:\n{e}\n\n{traceback.format_exc()}")


    def on_split_change(self, event=None):
        """Called when combo changes. Converts string to float ratio."""
        val = self.split_var.get()
        ratio = 0.5
        if val == "No Split": ratio = 1.0
        elif val == "75% Top": ratio = 0.75
        elif val == "50% / 50%": ratio = 0.5
        elif val == "25% Top": ratio = 0.25
        
        self.main_window.set_split_ratio(ratio)
        self.apply_changes()

    def apply_changes(self, event=None):
        """Collects all settings and applies them to the main window immediately."""
        # print(f"DEBUGGING: apply_changes triggered. Font: {self.font_fam_cb.get()}, Size: {self.font_size_cb.get()}")
        
        # Track changes that require Data Refresh vs UI Refresh
        needs_data_refresh = False
        
        if self.main_window.show_read != self.show_read_var.get(): needs_data_refresh = True
        if self.main_window.only_flagged != self.only_flagged_var.get(): needs_data_refresh = True
        
        # 1. Update Main Window Attributes
        self.main_window.font_family = self.font_fam_cb.get()
        self.main_window.font_size = int(self.font_size_cb.get())
        
        self.main_window.show_read = self.show_read_var.get()
        self.main_window.only_flagged = self.only_flagged_var.get()
        
        # Update Pane Types
        self.main_window.pane1_type = self.pane1_var.get()
        self.main_window.pane2_type = self.pane2_var.get()
        
        # Force layout update (rebuilds if needed)
        # Note: We do NOT set split_ratio here to avoid overwriting manual sash drags.
        # split_ratio is handled by on_split_change (dropdown) or sash drag events.
        self.main_window.set_split_ratio() # Call without args to just refresh layout/panes
        
        # Buttons
        new_config = []
        for row in self.action_rows:
            action = row["cb"].get()
            folder = row["folder"].get()
            
            # Auto-icon map
            icon = ""
            if action == "Reply": icon = "‚Ü©"
            elif action == "Delete": icon = "‚úï"
            elif action == "Mark Read": icon = "‚úì"
            elif action == "Flag": icon = "‚öë"
            elif action == "Move To...": icon = "üìÇ"
            elif action != "None": icon = "‚óè"
            
            new_config.append({
                "label": action,
                "icon": icon,
                "action1": action,
                "folder": folder
            })
        
        self.main_window.btn_config = new_config
        
        # 2. Trigger Refresh / Redraw
        if needs_data_refresh:
            self.main_window.refresh_emails()
        else:
            self.main_window.refresh_ui()
            
        self.main_window.save_config()

    def destroy(self):
        # Final save on close to be sure
        try:
            self.apply_changes()
        except Exception as e:
            print(f"Error applying changes on close: {e}")
        
        super().destroy()

class SidebarWindow(tk.Tk):
    def __init__(self):
        super().__init__()

        # --- Configuration ---
        self.min_width = 300  
        self.hot_strip_width = 10
        self.expanded_width = 300
        self.is_pinned = True # Default Pinned
        self.is_expanded = False
        self.dock_side = "Left" # "Left" or "Right"
        self.font_family = "Segoe UI"
        self.font_size = 9
        self.poll_interval = 30 # seconds
        self.show_read = True
        self.only_flagged = False
        self.include_read_flagged = True
        self.flag_date_filter = "Anytime"
        # self.icon_brightness = 1.0 # Removed
        self.hover_delay = 500 # ms
        self._hover_timer = None
        self._collapse_timer = None
        
        # Pulse Animation State
        self.pulsing = False
        self.pulse_step = 0
        self._pulse_job = None
        self.animation_speed = 0.05 # Increment per frame
        self.base_color = "#007ACC"
        self.pulse_color = "#99D9EA" # Lighter cyan/blue for the bar
        
        # Pane Config
        self.pane1_type = "Emails"     # Top / Primary
        self.pane2_type = "Reminders"  # Bottom / Secondary
        
        # Custom Buttons State
        self.btn_count = 2
        # Default config structure update
        self.btn_config = [
            {"label": "Trash", "icon": "‚úï", "action1": "Mark Read", "action2": "Delete", "folder": ""}, 
            {"label": "Reply", "icon": "‚Ü©", "action1": "Reply", "action2": "None", "folder": ""}
        ]
        
        # Email Cache (for instant redraws)
        self.current_emails = []
        
        # Load Config
        self.load_config()

        # --- Outlook Client ---
        self.outlook_client = OutlookClient()
        
        # Image Cache (to keep references alive)
        self.image_cache = {}

        # --- Window Setup ---
        self.overrideredirect(True)  # Frameless
        self.wm_attributes("-topmost", True)
        self.config(bg="#333333")

        # Get Screen Dimensions (will be updated in apply_state)
        self.monitor_x = 0
        self.monitor_y = 0
        self.screen_width = self.winfo_screenwidth()
        self.screen_height = self.winfo_screenheight()

        # --- AppBar Manager ---
        self.update_idletasks() 
        self.hwnd = ctypes.windll.user32.GetParent(self.winfo_id())
        if not self.hwnd:
             self.hwnd = self.winfo_id()

        self.appbar = AppBarManager(self.hwnd)
        
        # --- UI Components ---
        self.main_frame = tk.Frame(self, bg="#222222")
        self.main_frame.place(relx=0, rely=0, relwidth=1, relheight=1)

        # Footer
        self.footer = tk.Frame(self.main_frame, bg="#444444", height=40)
        self.footer.pack(fill="x", side="bottom")
        
        # Footer Buttons
        # Pack order: Rightmost first.
        
        # 1. Outlook Button (Rightmost)
        if os.path.exists("icons/Outlook_48x48.png"):
             # Increase size to 32x32
             try:
                pil_img = Image.open("icons/Outlook_48x48.png").convert("RGBA")
                pil_img = pil_img.resize((32, 32), Image.Resampling.LANCZOS)
                img = ImageTk.PhotoImage(pil_img)
                self.image_cache["outlook_footer"] = img
                self.btn_outlook = tk.Label(self.footer, image=img, bg="#444444", cursor="hand2")
                self.btn_outlook.pack(side="right", padx=(5, 10), pady=5)
                self.btn_outlook.bind("<Button-1>", lambda e: self.open_outlook_app())
                ToolTip(self.btn_outlook, "Open Outlook")
             except Exception as e:
                print(f"Error loading Outlook icon: {e}")

        # 0. Close Button (Leftmost)
        # Use a simple text button or icon if available
        self.btn_close = tk.Label(self.footer, text="‚úï", bg="#444444", fg="#aaaaaa", font=("Arial", 12), cursor="hand2")
        self.btn_close.pack(side="left", padx=10, pady=5)
        self.btn_close.bind("<Button-1>", lambda e: self.quit_application())
        ToolTip(self.btn_close, "Close Application")
                 
        # 2. Calendar Button (Next to Outlook)
        if os.path.exists("icons/OutlookCalendar_48x48.png"):
             # Increase size to 32x32
             try:
                pil_img = Image.open("icons/OutlookCalendar_48x48.png").convert("RGBA")
                pil_img = pil_img.resize((32, 32), Image.Resampling.LANCZOS)
                img = ImageTk.PhotoImage(pil_img)
                self.image_cache["calendar_footer"] = img
                self.btn_calendar = tk.Label(self.footer, image=img, bg="#444444", cursor="hand2")
                self.btn_calendar.pack(side="right", padx=5, pady=5)
                self.btn_calendar.bind("<Button-1>", lambda e: self.open_calendar_app())
                ToolTip(self.btn_calendar, "Open Calendar")
             except Exception as e:
                print(f"Error loading Calendar icon: {e}")

        # Header
        self.header = tk.Frame(self.main_frame, bg="#444444", height=40)
        self.header.pack(fill="x", side="top")
        
        # Header Dragging
        self.header.bind("<Button-1>", self.start_window_drag)
        self.header.bind("<B1-Motion>", self.on_window_drag)
        self.header.bind("<ButtonRelease-1>", self.stop_window_drag)
        
        # Title
        self.lbl_title = tk.Label(self.header, text="Outlook Monitor v1.1.0", bg="#444444", fg="white", font=(self.font_family, 10, "bold"))
        self.lbl_title.pack(side="left", padx=10)
        self.lbl_title.bind("<Button-1>", self.start_window_drag)
        self.lbl_title.bind("<B1-Motion>", self.on_window_drag)
        self.lbl_title.bind("<ButtonRelease-1>", self.stop_window_drag)

        # Pin Button / Logo (Custom Canvas)
        self.btn_pin = tk.Canvas(self.header, width=30, height=30, bg="#444444", highlightthickness=0)
        self.btn_pin.pack(side="right", padx=5, pady=5)
        self.btn_pin.bind("<Button-1>", lambda e: self.toggle_pin())
        self.draw_pin_icon()
        
        # Custom Settings Button (Cog)
        if os.path.exists("icons/Settings.png"):
            img = self.load_icon_white("icons/Settings.png", size=(24, 24))
            if img:
                self.image_cache["settings_header"] = img
                self.btn_settings = tk.Label(self.header, image=img, bg="#444444", cursor="hand2")
            else:
                 self.btn_settings = tk.Label(self.header, text="‚öô", bg="#444444", fg="#aaaaaa", font=(self.font_family, 12), cursor="hand2")
        else:
            self.btn_settings = tk.Label(self.header, text="‚öô", bg="#444444", fg="#aaaaaa", font=(self.font_family, 12), cursor="hand2")
        self.btn_settings.pack(side="right", padx=5)
        self.btn_settings.bind("<Button-1>", lambda e: self.open_settings())

        # Refresh Button
        if os.path.exists("icons/Sync.png"):
            # Increased by another 10% -> (28, 28)
            img = self.load_icon_white("icons/Sync.png", size=(28, 28))
            if img:
                self.image_cache["sync_header"] = img
                self.btn_refresh = tk.Label(self.header, image=img, bg="#444444", cursor="hand2")
            else:
                 self.btn_refresh = tk.Label(self.header, text="‚Üª", bg="#444444", fg="white", font=(self.font_family, 15), cursor="hand2")
        else:
            self.btn_refresh = tk.Label(self.header, text="‚Üª", bg="#444444", fg="white", font=(self.font_family, 15), cursor="hand2")
        self.btn_refresh.pack(side="right", padx=5)
        self.btn_refresh.bind("<Button-1>", lambda e: self.refresh_emails())
        
        ToolTip(self.btn_settings, "Settings")
        ToolTip(self.btn_refresh, "Refresh Email List")

        # Share Button
        if os.path.exists("icons/Share.png"):
            # Reduced by another 10% -> (20, 20)
            img = self.load_icon_white("icons/Share.png", size=(20, 20))
            if img:
                self.image_cache["share_header"] = img
                self.btn_share = tk.Label(self.header, image=img, bg="#444444", cursor="hand2")
            else:
                 self.btn_share = tk.Label(self.header, text="üîó", bg="#444444", fg="white", font=(self.font_family, 15), cursor="hand2")
        else:
            self.btn_share = tk.Label(self.header, text="üîó", bg="#444444", fg="white", font=(self.font_family, 15), cursor="hand2")
        self.btn_share.pack(side="right", padx=5)
        # No action yet, just tooltip
        ToolTip(self.btn_share, "Sharing not available yet")

        # Content Area - Split View (PanedWindow)
        # We need a PanedWindow to hold Email List (Top) and Reminders (Bottom)
        self.content_container = tk.Frame(self.main_frame, bg="#222222")
        self.content_container.pack(expand=True, fill="both", padx=5, pady=5)
        
        # SashRelief=FLAT to make it look modern (just a line)
        self.paned_window = tk.PanedWindow(self.content_container, orient=tk.VERTICAL, bg="#222222", sashwidth=4, sashrelief="flat")
        self.paned_window.pack(fill="both", expand=True)
        
        # --- Top Section: Email List ---
        self.email_pane = tk.Frame(self.paned_window, bg="#222222")
        self.scroll_frame = ScrollableFrame(self.email_pane, bg="#222222")
        self.scroll_frame.pack(expand=True, fill="both")
        
        self.paned_window.add(self.email_pane, minsize=100)
        
        # --- Bottom Section: Reminders / Flagged ---
        self.reminder_pane = tk.Frame(self.paned_window, bg="#222222")
        
        # Reminders Header
        self.rem_header = tk.Frame(self.reminder_pane, bg="#333333", height=25)
        self.rem_header.pack(fill="x", side="top")
        
        tk.Label(self.rem_header, text="‚ö† REMINDERS & FLAGGED", bg="#333333", fg="#aaaaaa", font=(self.font_family, 8, "bold"), anchor="w").pack(side="left", padx=5)
        
        # Reminders Content (Scrollable)
        self.reminder_scroll = ScrollableFrame(self.reminder_pane, bg="#222222")
        self.reminder_scroll.pack(expand=True, fill="both")
        
        self.paned_window.add(self.reminder_pane, minsize=50)
        
        # Track Sash Movement for Saving
        self.paned_window.bind("<ButtonRelease-1>", self.on_sash_release)

        # Set Initial Split (After idle to ensure geometry is calculated)
        # We want roughly 2/3 top, 1/3 bottom. 
        self.after(500, self.set_split_ratio)

    def on_sash_release(self, event):
        """Updates split_ratio when user drags the sash."""
        try:
            # sash_coord(0) returns (x, y). We want y.
            sash_pos = self.paned_window.sash_coord(0)[1]
            height = self.paned_window.winfo_height()
            if height > 0:
                self.split_ratio = sash_pos / height
                # Clamp
                if self.split_ratio > 0.95: self.split_ratio = 1.0 # Snap to hidden? No, leave as is, save_config handles it?
                print(f"DEBUG: Sash moved. New Ratio: {self.split_ratio:.2f}")
        except Exception as e:
            print(f"Error tracking sash: {e}")

    def set_split_ratio(self, ratio=None):
        try:
            if ratio: self.split_ratio = ratio
            # print(f"DEBUGGING set_split_ratio: Ratio={self.split_ratio}, P1={self.pane1_type}, P2={self.pane2_type}")

            # Define Widgets map
            widgets = {
                "Emails": self.email_pane,
                "Reminders": self.reminder_pane
            }
            
            # Determine Top (Primary) and Bottom (Secondary) widgets
            # Fallback to defaults if invalid type
            p1 = widgets.get(self.pane1_type, self.email_pane)
            p2 = widgets.get(self.pane2_type, self.reminder_pane)
            
            # If No Split (Full Screen Primary)
            if self.split_ratio >= 0.95:
                # 1. Ensure P1 is visible and covers everything
                current_panes = self.paned_window.panes()
                
                # Check if we need to reset to just P1
                if len(current_panes) != 1 or current_panes[0] != str(p1):
                    # Reset
                    for w in self.paned_window.panes():
                        try: self.paned_window.forget(w) 
                        except: pass
                    self.paned_window.add(p1, minsize=100)
                return

            else:
                # Split View: P1 Top, P2 Bottom
                current_panes = self.paned_window.panes() # strings
                
                # Check if we need to rebuild layout
                rebuild = False
                if len(current_panes) < 2: 
                    rebuild = True
                elif str(p1) != current_panes[0] or str(p2) != current_panes[1]:
                    rebuild = True
                
                if rebuild:
                    print("DEBUGGING: Rebuilding Layout Order")
                    for w in self.paned_window.panes():
                         try: self.paned_window.forget(w) 
                         except: pass
                    self.paned_window.add(p1, minsize=100)
                    self.paned_window.add(p2, minsize=50)
            
            # 2. Set Sash Position
            self.paned_window.update() # Force geometry update
            h = self.paned_window.winfo_height()
            
            # Safety check for valid height
            if h < 50: 
                print(f"DEBUGGING: Height too small ({h}), retrying...")
                self.after(500, lambda: self.set_split_ratio(self.split_ratio))
                return

            sash_pos = int(h * self.split_ratio)
            # Check limits
            if sash_pos > (h - 20): sash_pos = h - 20
            
            # print(f"DEBUGGING Sash: h={h}, ratio={self.split_ratio}, pos={sash_pos}")
            
            self.paned_window.sash_place(0, 0, sash_pos)
            
        except Exception as e:
            print(f"Error set_split_ratio: {e}")


        # Resize Grip (Overlay on the right edge)
        self.resize_grip = tk.Frame(self.main_frame, bg="#666666", cursor="sb_h_double_arrow", width=5)
        self.resize_grip.place(relx=1.0, rely=0, anchor="ne", relheight=1.0)
        self.resize_grip.bind("<B1-Motion>", self.on_resize_drag)
        self.resize_grip.bind("<ButtonRelease-1>", self.on_resize_release)

        # Hot Strip Visual overlay (only visible when collapsed)
        # We use a Canvas now to draw the animation
        self.hot_strip_canvas = tk.Canvas(self.main_frame, bg="#007ACC", highlightthickness=0)
        
        # --- Events ---
        self.bind("<Enter>", self.on_enter)
        self.bind("<Leave>", self.on_leave)
        self.bind("<Motion>", self.on_motion) 

        # Initial State
        self.apply_state()
        
        # Enforcer
        self.bind("<Map>", self.on_map_event)
        
        # Initial Load (Scheduled to run after UI is ready)
        self.after(100, self.refresh_emails)

    def quit_application(self):
        """Terminates the application."""
        self.destroy()
        sys.exit(0)



    def open_settings(self):
        # Callback is now refresh_emails to rebuild cards with new button config
        SettingsWindow(self, self.refresh_emails)
        
    def load_icon_white(self, path, size=None):
        """Loads an image, converts it to white, and returns ImageTk.PhotoImage."""
        try:
            pil_img = Image.open(path).convert("RGBA")
            
            # Resize if needed
            if size:
                pil_img = pil_img.resize(size, Image.Resampling.LANCZOS)
                
            r, g, b, a = pil_img.split()
            
            # Use static brightness (White/Light Grey)
            color_val = 220 # Brighter than 191
            white_img = Image.new("RGBA", pil_img.size, (color_val, color_val, color_val, 255))
            
            # Simple threshold mask for visibility
            mask = a.point(lambda p: 255 if p > 20 else 0)
             
            # Use masked image
            final_img = Image.new("RGBA", pil_img.size, (0, 0, 0, 0))
            final_img.paste(white_img, (0, 0), mask=mask)
            
            return ImageTk.PhotoImage(final_img)
        except Exception as e:
            print(f"Error loading/coloring icon {path}: {e}")
            return None

    def handle_custom_action(self, config, email_data):
        """Executes the selected actions on the specific email."""
        print(f"Executing Actions for {config.get('label')} on {email_data.get('subject')}")
        
        entry_id = email_data.get("entry_id")
        if not entry_id:
            print("No EntryID found.")
            return

        item = self.outlook_client.get_item_by_entryid(entry_id)
        if not item:
            print("Could not retrieve Outlook item.")
            return

        # Sequential Execution Helper
        def execute_single_action(act_name, folder_name=""):
            if not act_name or act_name == "None": return
            
            try:
                if act_name == "Mark Read":
                    item.UnRead = False
                    item.Save()
                elif act_name == "Delete":
                    item.Delete()
                elif act_name == "Read & Delete":
                    item.UnRead = False
                    item.Save()
                    item.Delete()
                elif act_name == "Flag":
                    if item.IsMarkedAsTask: item.ClearTaskFlag()
                    else: item.MarkAsTask(4)
                    item.Save()
                elif act_name == "Open Email":
                    item.Display()
                    try:
                        # Maximize Window
                        inspector = item.GetInspector
                        inspector.WindowState = 2 # olMaximized
                        # Force window to front
                        inspector.Activate()
                    except:
                        pass
                elif act_name == "Reply":
                    # Mark as read first
                    item.UnRead = False
                    item.Save()
                    
                    reply = item.Reply()
                    reply.Display()
                    try:
                        # Maximize Window
                        inspector = reply.GetInspector
                        inspector.WindowState = 2 # olMaximized
                        inspector.Activate()
                    except:
                        pass
                elif act_name == "Move To...":
                    if folder_name:
                        target = self.outlook_client.find_folder_by_name(folder_name)
                        if target: item.Move(target)
                        else: print(f"Folder '{folder_name}' not found.")
            except Exception as e:
                print(f"Error executing {act_name}: {e}")

        try:
            # Execute Action 1
            execute_single_action(config.get("action1"), config.get("folder"))
            
            # Execute Action 2 - REMOVED
            # execute_single_action(config.get("action2"), config.get("folder"))
                
            # Refresh UI
            self.after(500, self.refresh_emails)
            
        except Exception as e:
            print(f"Action execution loop error: {e}")

    def toggle_card_actions(self, action_frame):
        if action_frame.winfo_viewable():
            action_frame.pack_forget()
        else:
            action_frame.pack(fill="x", pady=(5, 0))

    def start_polling(self):
        self.start_polling()
        
    def start_polling(self):
        """Poll Outlook every 30 seconds for new mail."""
        if self.outlook_client.check_new_mail():
            self.start_pulse()
            self.refresh_emails() # Auto-refresh list
            
        self.after(self.poll_interval * 1000, self.start_polling) # Dynamic interval
        
    def start_pulse(self):
        if not self.pulsing:
            self.pulsing = True
            self.pulse_step = 0
            self.run_pulse_animation()
            
    def stop_pulse(self):
        if self.pulsing:
            self.pulsing = False
            if self._pulse_job:
                self.after_cancel(self._pulse_job)
                self._pulse_job = None
            # Reset
            self.hot_strip_canvas.delete("pulse")

    def run_pulse_animation(self):
        if not self.pulsing: return
        
        # Calculate Height factor using sine wave (0.0 to 1.0)
        # math.sin goes from -1 to 1. We want 0 to 1 back to 0.
        # shifting phase to start at 0
        factor = (math.sin(self.pulse_step) + 1) / 2 # 0 to 1
        
        # Alternatively, for a "growth" from center:
        # We can just cycle 0 -> PI
        
        self.hot_strip_canvas.delete("pulse")
        
        w = self.hot_strip_width
        h = self.screen_height
        
        # Dynamic height based on factor
        # Let's make it grow to full height then shrink
        bar_height = h * factor
        
        # Center coords
        y1 = (h / 2) - (bar_height / 2)
        y2 = (h / 2) + (bar_height / 2)
        
        # Draw the "light" bar
        self.hot_strip_canvas.create_rectangle(
            0, y1, w, y2,
            fill=self.pulse_color,
            outline="",
            tags="pulse"
        )
        
        self.pulse_step += self.animation_speed
        
        # Speed: 50ms (20fps) for smooth gentle pulse
        self._pulse_job = self.after(50, self.run_pulse_animation)

    # --- Outlook Window Management (COM-based) ---

    def _get_outlook_app(self):
        """
        Gets the Outlook Application COM object.
        Tries GetActiveObject first (reuses existing instance), falls back to Dispatch.
        """
        try:
            # Try to connect to already-running Outlook
            app = win32com.client.GetActiveObject("Outlook.Application")
            return app
        except:
            pass
        
        # Fall back to Dispatch (may start Outlook if not running)
        try:
            app = win32com.client.Dispatch("Outlook.Application")
            return app
        except Exception:
            return None

    def _get_any_explorer(self, app):
        """
        Returns an existing Explorer window if one exists, otherwise None.
        Tries ActiveExplorer first, then iterates Explorers collection.
        """
        if not app:
            return None
        
        # Try ActiveExplorer first
        try:
            explorer = app.ActiveExplorer()
            if explorer:
                return explorer
        except:
            pass
        
        # Iterate Explorers collection
        try:
            explorers = app.Explorers
            if explorers.Count > 0:
                return explorers.Item(1)
        except Exception:
            pass
        
        return None

    def _focus_window_by_hwnd(self, hwnd):
        """
        Brings a window to the foreground by its hwnd.
        Handles minimized windows and SetForegroundWindow restrictions.
        """
        if not hwnd:
            return False
        
        try:
            # Check if minimized
            if user32.IsIconic(hwnd):
                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            else:
                win32gui.ShowWindow(hwnd, win32con.SW_SHOW)
            
            # SetForegroundWindow can fail if our process doesn't have focus
            # Workaround: briefly set TOPMOST then remove it
            try:
                win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0,
                                      win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)
                win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0,
                                      win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)
            except:
                pass
            
            win32gui.SetForegroundWindow(hwnd)
            return True
        except Exception:
            return False

    def _show_outlook_folder(self, folder_id):
        """
        Shows the specified Outlook folder (6=Inbox, 9=Calendar).
        Reuses existing Explorer if available, otherwise creates one.
        """
        try:
            app = self._get_outlook_app()
            if not app:
                return
            
            ns = app.GetNamespace("MAPI")
            folder = ns.GetDefaultFolder(folder_id)
            
            # Try to get existing explorer
            explorer = self._get_any_explorer(app)
            
            if explorer:
                # Reuse existing explorer - switch folder
                try:
                    explorer.CurrentFolder = folder
                except Exception:
                    pass
                
                # Get hwnd and focus
                try:
                    hwnd = explorer.Hwnd if hasattr(explorer, 'Hwnd') else None
                    if hwnd:
                        self._focus_window_by_hwnd(hwnd)
                    else:
                        explorer.Activate()
                except Exception:
                    pass
            else:
                # No explorer exists - create one via GetExplorer
                try:
                    new_explorer = folder.GetExplorer()
                    new_explorer.Display()
                    
                    # Focus the new window
                    self.after(100, lambda: self._focus_window_by_hwnd(
                        new_explorer.Hwnd if hasattr(new_explorer, 'Hwnd') else None
                    ))
                except Exception:
                    # Ultimate fallback
                    folder.Display()
                    
        except Exception:
            pass

    def open_outlook_app(self):
        """Opens/Focuses the main Outlook window (Inbox)."""
        self._show_outlook_folder(6)  # 6 = olFolderInbox

    def open_calendar_app(self):
        """Opens/Focuses the Outlook Calendar."""
        self._show_outlook_folder(9)  # 9 = olFolderCalendar
        
    def load_config(self):
        try:
            with open("sidebar_config.json", "r") as f:
                data = json.load(f)
                self.expanded_width = data.get("width", 300)
                self.is_pinned = data.get("pinned", True)
                self.dock_side = data.get("dock_side", "Left")
                self.split_ratio = data.get("split_ratio", 0.66)
                self.pane1_type = data.get("pane1_type", "Emails")
                self.pane2_type = data.get("pane2_type", "Reminders")
                self.font_family = data.get("font_family", "Segoe UI")
                self.font_size = data.get("font_size", 9)
                self.poll_interval = data.get("poll_interval", 30)
                self.btn_count = data.get("btn_count", 2)
                self.btn_config = data.get("btn_config", [])
            
                # Validate Button Config (Restore defaults if empty)
                if not self.btn_config or len(self.btn_config) == 0:
                     self.btn_config = [
                        {"label": "Trash", "icon": "‚úï", "action1": "Mark Read", "action2": "Delete", "folder": ""}, 
                        {"label": "Reply", "icon": "‚Ü©", "action1": "Reply", "action2": "None", "folder": ""}
                    ]

                self.show_read = data.get("show_read", True)
                self.only_flagged = data.get("only_flagged", False)
                self.include_read_flagged = data.get("include_read_flagged", True)
                self.flag_date_filter = data.get("flag_date_filter", "Anytime")
        except (FileNotFoundError, json.JSONDecodeError):
            print("Config file not found or corrupt. Using defaults.")
            # Ensure defaults are set if load fails
            self.btn_config = [
                {"label": "Trash", "icon": "‚úï", "action1": "Mark Read", "action2": "Delete", "folder": ""}, 
                {"label": "Reply", "icon": "‚Ü©", "action1": "Reply", "action2": "None", "folder": ""}
            ]

    def save_config(self):
        data = {
            "width": self.expanded_width,
            "pinned": self.is_pinned,
            "dock_side": self.dock_side,
            "split_ratio": self.split_ratio,
            "pane1_type": self.pane1_type,
            "pane2_type": self.pane2_type,
            "font_family": self.font_family,
            "font_size": self.font_size,
            "poll_interval": self.poll_interval,
            "btn_count": self.btn_count,
            "btn_config": self.btn_config,
            "show_read": self.show_read,
            "only_flagged": self.only_flagged,
            "include_read_flagged": self.include_read_flagged,
            "flag_date_filter": self.flag_date_filter
        }
        with open("sidebar_config.json", "w") as f:
            json.dump(data, f)

    def refresh_emails(self):
        """Fetches data from Outlook and then triggers a UI refresh."""
        try:
            self.current_emails = self.outlook_client.get_inbox_items(
                count=30, 
                unread_only=not self.show_read,
                only_flagged=self.only_flagged,
                include_read_flagged=self.include_read_flagged,
                flag_date_filter=self.flag_date_filter
            )
            self.refresh_ui()
        except Exception as e:
            print(f"Error fetching emails: {e}")

    def refresh_ui(self):
        """Re-renders the email list using cached data and current settings (fonts/colors)."""
        print(f"DEBUGGING: refresh_ui called. Font: {self.font_family}, Size: {self.font_size}")
        # Update UI fonts for header elements
        try:
            self.lbl_title.config(font=(self.font_family, 10, "bold"))
            self.btn_settings.config(font=(self.font_family, 12))
            self.btn_refresh.config(font=(self.font_family, 15))
        except Exception as e:
            print(f"Error updating header fonts: {e}") 

        # Clear existing
        try:
            for widget in self.scroll_frame.scrollable_frame.winfo_children():
                widget.destroy()
        except Exception as e:
             print(f"Error clearing widgets: {e}")
             return # UI not ready

        print(f"DEBUGGING: Rendering {len(self.current_emails)} emails.")
        for email in self.current_emails:
            # Determine styling based on UnRead status
            is_unread = email.get('unread', False)
            bg_color = "#2d2d2d"
            # Blue border for unread, grey for read
            border_color = "#007ACC" if is_unread else "#555555"
            border_width = 2 if is_unread else 1
            
            # Create Card
            card = tk.Frame(
                self.scroll_frame.scrollable_frame, 
                bg=bg_color, 
                highlightbackground=border_color, 
                highlightthickness=border_width,
                padx=5, pady=5
            )
            card.pack(fill="x", expand=True, padx=2, pady=2)
            
            # --- Badge System (Follow-up Indicators) ---
            badge_text = ""
            badge_bg = "#555555" # Default
            
            if email.get('flag_status', 0) != 0:
                due = email.get('due_date')
                now_dt = datetime.now()
                received = email.get('received')
                
                # Check for 4501 "No Date"
                is_real_due = False
                if due:
                    try:
                        # Extract date part for comparison
                        due_short = due.replace(hour=0, minute=0, second=0, microsecond=0)
                        now_short = now_dt.replace(hour=0, minute=0, second=0, microsecond=0)
                        
                        if due_short.year < 3000: # Not the 4501 placeholder
                            is_real_due = True
                            diff = (due_short - now_short).days
                            
                            if diff < 0:
                                badge_text = "OVERDUE"
                                badge_bg = "#D83B01" # Dark Red/Orange
                            elif diff == 0:
                                badge_text = "DUE TODAY"
                                badge_bg = "#FF8C00" # Orange
                            elif diff == 1:
                                badge_text = "TOMORROW"
                                badge_bg = "#0078D4" # Blue
                            elif diff < 7:
                                badge_text = due_short.strftime("%a").upper()
                                badge_bg = "#00B7C3" # Teal
                            else:
                                badge_text = due_short.strftime("%d %b").upper()
                                badge_bg = "#666666"
                    except:
                        pass

                if not is_real_due and received:
                    # Show "Flagged X days ago"
                    try:
                        diff = (now_dt.astimezone() - received.astimezone()).days
                        if diff == 0:
                            badge_text = "FLAGGED TODAY"
                        else:
                            badge_text = f"FLAGGED {diff}D"
                        badge_bg = "#8E8E8E"
                    except:
                        pass

            header_frame = tk.Frame(card, bg=bg_color)
            header_frame.pack(fill="x")

            # Sender
            sender_text = email['sender']
            if is_unread:
                sender_text = "‚óè " + sender_text # Add indicator dot
                
            lbl_sender = tk.Label(
                header_frame, 
                text=sender_text, 
                fg="white", 
                bg=bg_color, 
                font=(self.font_family, self.font_size, "bold"),
                anchor="w"
            )
            lbl_sender.pack(side="left", fill="x", expand=True)

            if badge_text:
                lbl_badge = tk.Label(
                    header_frame, 
                    text=badge_text, 
                    fg="white", 
                    bg=badge_bg, 
                    font=(self.font_family, self.font_size - 2, "bold"),
                    padx=6, pady=2
                )
                lbl_badge.pack(side="right", padx=2)
                
            # Subject
            lbl_subject = tk.Label(
                card, 
                text=email['subject'], 
                fg="#cccccc", 
                bg=bg_color, 
                font=(self.font_family, self.font_size),
                anchor="w",
                justify="left",
                wraplength=self.expanded_width - 40 
            )
            lbl_subject.pack(fill="x")
            
            # Preview (Body)
            lbl_preview = tk.Label(
                card, 
                text=email['preview'], 
                fg="#999999", 
                bg=bg_color, 
                font=(self.font_family, self.font_size - 1),
                anchor="w",
                justify="left",
                wraplength=self.expanded_width - 40
            )
            lbl_preview.pack(fill="x", pady=(2, 5))
            
            # --- Quick Actions (Hover) ---
            # Container for buttons (Initially hidden or shown on hover? Design choice: Always show for now or on hover)
            # Simpler: Always show action buttons at bottom of card for now, or just right aligned in header? 
            # Current design: Bottom row
            
            btn_frame = tk.Frame(card, bg=bg_color)
            btn_frame.pack(fill="x", pady=2)
            
            # We will use the custom buttons from config
            # But we need to map them to logic. 
            
            for btn_conf in self.btn_config:
                label = btn_conf.get("label", "Action")
                if label == "None" or not label: continue
                
                icon = btn_conf.get("icon", "")
                
                # Create Button
                btn = tk.Label(
                    btn_frame, 
                    text=f"{icon} {label}" if icon else label,
                    fg="#aaaaaa",
                    bg=bg_color,
                    font=(self.font_family, self.font_size - 2),
                    padx=8, pady=4,
                    cursor="hand2"
                )
                
                # If only 1 button, restrict width slightly to avoid massive button
                if len(self.btn_config) == 1:
                    btn.pack(side="left", expand=True, fill="y", ipadx=20)
                else:
                    btn.pack(side="left", expand=True, fill="both")
                
                # Bind hover
                btn.bind("<Enter>", lambda e, b=btn: b.config(bg="#444444"))
                btn.bind("<Leave>", lambda e, b=btn, bg=bg_color: b.config(bg=bg))
                
                # Tooltip logic
                act1 = btn_conf.get("action1", "")
                act2 = btn_conf.get("action2", "None")
                if act2 != "None":
                    tip_text = f"{act1} & {act2}"
                else:
                    tip_text = act1
                
                ToolTip(btn, tip_text)
                
                # Click handler
                btn.bind("<Button-1>", lambda e, c=btn_conf, em=email: self.handle_custom_action(c, em))
            
            # --- Bindings Removed ---
            # card.bind("<Button-1>", ...) 
            
            # Dynamic wrapping for both labels
            def update_wraps(e, s=lbl_subject, p=lbl_preview):
                width = e.width - 20
                s.config(wraplength=width)
                p.config(wraplength=width)
                
            card.bind("<Configure>", update_wraps)

    def draw_pin_icon(self):
        self.btn_pin.delete("all")
        color = "#007ACC" if self.is_pinned else "#AAAAAA"
        # Draw a simple pin shape
        self.btn_pin.create_oval(10, 5, 20, 15, fill=color, outline="")
        self.btn_pin.create_line(15, 15, 15, 25, fill=color, width=2)

    def toggle_pin(self):
        self.is_pinned = not self.is_pinned
        self.draw_pin_icon()
        self.save_config()
        self.apply_state()

    def log(self, message):
        """Writes debug message to file."""
        try:
            with open("sidebar_debug.txt", "a") as f:
                f.write(f"{datetime.now()}: {message}\n")
        except: pass

    def apply_state(self):
        """Applies the current state (Pinned/Expanded/Collapsed) to the window and AppBar."""
        self.log(f"apply_state: Pinned={self.is_pinned}, Expanded={self.is_expanded}")
        # Update monitor info to ensure correct sizing on monitor change
        self.monitor_x, self.monitor_y, self.screen_width, self.screen_height = self.get_current_monitor_info()
        self.log(f"Monitor: x={self.monitor_x}, y={self.monitor_y}, w={self.screen_width}, h={self.screen_height}")

        # Update AppBar edge based on preference
        new_edge = ABE_LEFT if self.dock_side == "Left" else ABE_RIGHT
        
        # If side changed, we MUST unregister the old one first to release the old edge
        if self.appbar.edge != new_edge:
            self.appbar.unregister()
            self.appbar.edge = new_edge
            self.appbar.abd.uEdge = new_edge

        if self.is_pinned:
            # Pinned: Always Expanded, Always Reserved (Docked)
            self.hot_strip_canvas.place_forget()
            self.header.pack(fill="x", side="top")
            self.content_container.pack(expand=True, fill="both", padx=5, pady=5)
            
            # Place grip on opposite side of dock
            if self.dock_side == "Left":
                self.resize_grip.place(relx=1.0, rely=0, anchor="ne", relheight=1.0)
            else:
                self.resize_grip.place(relx=0.0, rely=0, anchor="nw", relheight=1.0)
            
            self.appbar.register() # This will re-register on the new edge
            # Use authoritative position from Windows to avoid gaps
            try:
                x, y, w, h = self.appbar.set_pos(self.expanded_width, self.monitor_x, self.monitor_y, self.screen_width, self.screen_height)
                self.log(f"AppBar set_pos raw: x={x}, y={y}, w={w}, h={h}")
                
                # Sanity Check: If AppBar gives us garbage height (e.g. 0), force full screen
                if h < 200:
                    self.log(f"WARNING: Invalid AppBar height {h}. Forcing {self.screen_height}")
                    h = self.screen_height
                    y = self.monitor_y # Reset Y to top
                    # Recalculate X if needed? 
                    if self.dock_side == "Left":
                        x = self.monitor_x
                    else:
                        x = self.monitor_x + self.screen_width - w

            except Exception as e:
                self.log(f"Error setting AppBar pos: {e}")
                # Fallback
                w = self.expanded_width
                h = self.screen_height
                x = self.monitor_x if self.dock_side == "Left" else (self.monitor_x + self.screen_width - w)
                y = self.monitor_y
            
            # CRITICAL: Int cast for geometry
            x, y, w, h = int(x), int(y), int(w), int(h)
            geom_str = f"{w}x{h}+{x}+{y}"
            self.log(f"Applying Geometry: {geom_str}")
            self.geometry(geom_str)
            self.update_idletasks()
            self.is_expanded = True
            
        elif self.is_expanded:
            # Expanded (Hover): Broad width, BUT acts as OVERLAY (No docking/reservation)
            self.hot_strip_canvas.place_forget()
            self.header.pack(fill="x", side="top")
            # For overlay mode, we still show the content
            self.content_container.pack(expand=True, fill="both", padx=5, pady=5)
            
            if self.dock_side == "Left":
                self.resize_grip.place(relx=1.0, rely=0, anchor="ne", relheight=1.0)
            else:
                self.resize_grip.place(relx=0.0, rely=0, anchor="nw", relheight=1.0)
            
            # Unregister AppBar so we don't push other windows
            self.appbar.unregister()
            
            self.set_geometry(self.expanded_width)
            
        else:
            # Collapsed: Thin width, Overlay
            self.appbar.unregister() # Release space
            
            # Hide internals to prevent squishing
            self.header.pack_forget()
            self.content_container.pack_forget()
            self.resize_grip.place_forget()
            
            # Show Hot Strip
            self.hot_strip_canvas.place(relx=0, rely=0, relwidth=1, relheight=1)
            
            self.set_geometry(self.hot_strip_width)

    def on_map_event(self, event):
        """Called when window is mapped (shown). Enforces geometry check."""
        self.after(500, self.enforce_geometry)
        
    def enforce_geometry(self):
        """Final failsafe to ensure window is full height."""
        try:
            h = self.winfo_height()
            self.log(f"Enforce Verify: Current h={h}, Screen h={self.winfo_screenheight()}")
            if h < (self.winfo_screenheight() - 100): # Allow small margin
                self.log("Enforce Triggered: Maximizing height")
                self.apply_state() # Re-apply
        except Exception as e:
            self.log(f"Error in enforce_geometry: {e}")

    def on_resize_drag(self, event):
        if self.is_pinned or self.is_expanded:
            x_root = self.winfo_pointerx()
            
            # Calculate width based on side
            if self.dock_side == "Left":
                new_width = x_root - self.monitor_x
            else:
                new_width = (self.monitor_x + self.screen_width) - x_root
            
            if new_width > self.min_width and new_width < (self.screen_width // 2):
                self.expanded_width = new_width
                # Optimization: ONLY resize the visual window, do NOT trigger AppBar reflow
                self.set_geometry(self.expanded_width)
                # Ensure the content knows we resized if needed (pack handles this)

    def on_resize_release(self, event):
        # Commit the new width to the system (triggers reflow once)
        self.apply_state() 
        self.save_config()

    def set_geometry(self, width):
        # Always dock to preferred side, full height of CURRENT screen
        mx, my, mw, mh = self.get_current_monitor_info()
        
        if self.dock_side == "Left":
            x = mx
        else:
            x = mx + mw - width
            
        self.geometry(f"{width}x{mh}+{x}+{my}")
        # Ensure window updates its position immediately
        self.update_idletasks()
        # Force top most again just in case
        self.wm_attributes("-topmost", True)

    def get_current_monitor_info(self):
        """Retrieves the geometry of the monitor closest to the window center."""
        hwnd = self.winfo_id()
        # Ensure we have the actual top-level window handle
        hwnd = ctypes.windll.user32.GetParent(hwnd) or hwnd
        monitor = user32.MonitorFromWindow(hwnd, 2) # MONITOR_DEFAULTTONEAREST
        
        mi = MONITORINFO()
        mi.cbSize = ctypes.sizeof(MONITORINFO)
        if user32.GetMonitorInfoW(monitor, ctypes.byref(mi)):
            return (mi.rcMonitor.left, mi.rcMonitor.top, 
                    mi.rcMonitor.right - mi.rcMonitor.left, 
                    mi.rcMonitor.bottom - mi.rcMonitor.top)
            
        # Fallback to defaults
        return (0, 0, self.winfo_screenwidth(), self.winfo_screenheight())

    def start_window_drag(self, event):
        self._win_drag_x = event.x
        self._win_drag_y = event.y
        # Temporarily unregister AppBar so we can move freely
        self.appbar.unregister()

    def on_window_drag(self, event):
        deltax = event.x - self._win_drag_x
        deltay = event.y - self._win_drag_y
        x = self.winfo_x() + deltax
        y = self.winfo_y() + deltay
        # During drag, we don't snap/resize, just move
        self.geometry(f"+{x}+{y}")

    def stop_window_drag(self, event):
        # Auto-Snap Logic
        mx, my, mw, mh = self.get_current_monitor_info()
        
        # Calculate window center
        win_x = self.winfo_x()
        win_w = self.winfo_width()
        win_center = win_x + (win_w / 2)
        
        # Monitor center
        mon_center = mx + (mw / 2)
        
        # Determine side
        if win_center < mon_center:
            self.dock_side = "Left"
        else:
            self.dock_side = "Right"
            
        # Re-apply state which will snap to monitor edge and re-register
        self.apply_state()


    def on_enter(self, event):
        # Stop pulsing on interaction
        self.stop_pulse()
        
        if self._collapse_timer:
            self.after_cancel(self._collapse_timer)
            self._collapse_timer = None
        
        if not self.is_pinned and not self.is_expanded:
            self.is_expanded = True
            self.apply_state() # Expand and reserve space

    def on_leave(self, event):
        # We need to be careful. Leaving the window to the desktop should collapse.
        # But verify we aren't just hovering a child widget (Tkinter events bubble, but checking coordinates keeps us safe).
        x, y = self.winfo_pointerxy()
        widget_under_mouse = self.winfo_containing(x, y)
        
        # If we are really outside the window
        if not self.is_pinned and self.is_expanded:
             # Delay collapse
             if self._collapse_timer:
                 self.after_cancel(self._collapse_timer)
             self._collapse_timer = self.after(self.hover_delay, self.do_collapse)

    def on_motion(self, event):
        # Reset collapse timer if moving inside
        if self._collapse_timer:
             self.after_cancel(self._collapse_timer)
             self._collapse_timer = None

    def do_collapse(self):
        if not self.is_pinned:
            self.is_expanded = False
            self.apply_state() # Collapse and release space



# --- Single Instance Logic (Mutex) ---

class SingleInstance:
    """
    Limits application to a single instance using a Named Mutex.
    Safe for MSIX and standard execution.
    """
    def __init__(self, name="Global\\OutlookSidebar_Mutex_v1"):
        self.mutex_name = name
        self.mutex_handle = None
        self.last_error = 0

    def already_running(self):
        # CreateMutexW will return a handle. If it already existed, GetLastError returns ERROR_ALREADY_EXISTS
        ERROR_ALREADY_EXISTS = 183
        
        self.mutex_handle = kernel32.CreateMutexW(None, False, self.mutex_name)
        self.last_error = kernel32.GetLastError()
        
        if self.last_error == ERROR_ALREADY_EXISTS:
            return True
        return False
        
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if self.mutex_handle:
            kernel32.CloseHandle(self.mutex_handle)

if __name__ == "__main__":
    # Check Single Instance
    app_instance = SingleInstance()
    if app_instance.already_running():
        # Optional: Bring existing window to front (Requires FindWindow/SetForegroundWindow logic)
        # For now, just exit silently or print
        # messagebox.showinfo("Outlook Sidebar", "The application is already running.")
        sys.exit(0)

    # Keep the mutex handle alive for the duration of the app
    app = SidebarWindow()
    app.mainloop()

